< 2018 2학기 최지웅 교수님 알고리즘 중간고사 >

1번 오메가 차수 증명문제 (10점)
(n^2/2 - 1 이 omega(n^2)임을 보이기) - 1단원 ppt 58~64p


2번 로피탈의 정리로 small o 증명하기 (10점)
(2^n 이 o(3^n)임을 보이기) - 1단원 ppt 75p 

한줄평 : 지수함수의 미분을 할 줄 알아야 해! (시험끝나고 이거때문에 많이들 멘탈 나간듯 하더라..)


3번 마스터정리로 차수보이기 (10점)
(T(n) = root(2)*T(n/2) + log n) - 2단원 ppt 57p


4번 Every Case Time Complexity 보이기

< 다음과 같은 예시가 나왔어! >

* n은 2의 거듭제곱이라고 가정
function (n) {
    cout << 출력;
    function(n/2);
    function(n/2);
}

basic operation : cout부분

한줄평 : 어느 부분에서 나왔다고 말하기 애매한 부분이 있음!
나는 T(n) = T(n/2) + T(n/2) + 1로 점화식을 두고 문제를 풀었어!


5번 이항계수 나타내는 코드가 dynamic programming으로 제시됨, 빈칸채우기
(단, 1차원배열로 구현되어있어 공간복잡도가 향상된 버전이었음, 이는 수업시간에 말로만 설명한 부분(코드를 다루지는 않음).... 수업시간에 다룬 코드는 2차원배열) -> 3단원 p13 (Possible improvement of Algorithm 3.2)

참고 : http://emzei.tistory.com/213

< 아래 코드가 그대로 나왔어! 이 코드에서 빈칸이 곳곳에 있었음!!, 물론 나는 다 맞음ㅎㅎ >

int bin2(int n, int k) { 

        int i, j;  

        for(i=0; i<=n; i++) 

                for(j=i; j >= 0; j--)

                        if  

                                (j==0 || j == i) B[j] = 1;
                        else 

                                B[j] = B[j-1] + B[j]; 
        return B[k]; 

}


6번 QuickSort를 나타내는 코드가 divide-and-conquer로 제시됨,
partition부분 빈칸채우기(5점) - 2장 32p, 33p 변형
 - pivot을 맨 뒤 배열의 원소로 정함
 - 내림차순으로 정렬된 배열이 입력으로 들어올 때, quicksort부분 점화식세우기(5점)

한줄평 : 이거는 우리가 다루지 못한 내용으로, 이 알고리즘의 코드를 이해하고 적용해야 해!


7번 Optimal Binary Search Tree를 구성하기 위한 데이터가 주어짐
- key배열 : a b c
- 확률 : 0.3 0.1 0.6

A 배열과 R배열을 완성하고(5점) 트리 그리기(5점) - 3단원 p58처럼 쓰면 되여!


8번 floyd의 알고리즘에 대한 설명과 코드가 주어짐
- 이를 간선의 개수가 있으면 1로, 없으면 0으로 표시하는 알고리즘으로 변경하고자 함
-> 코드가 제시되었으며 빈칸 완성 문제(pesudo code로 작성하는 부분 하나, 연산자(+×) 넣는 부분 둘)

한줄평 : 이거는 우리가 다루지 못한 내용으로, 이 알고리즘의 코드를 이해하고 적용해야 해!



9번 Strassen의 알고리즘 코드가 제시됨(단, 임계점이 1이었음, 즉 2 by 2행렬도 Strassen의 방법으로 계산함 - 이거 못봤음 틀렸을듯) -> 2단원 p 48 (기본 : strassen의 방법은 7번의 곱셈과 18번의 덧셈을 필요로 한다.)
- 32*32 행렬을 Strassen의 알고리즘으로 계산할 때 곱셈의 총 횟수 구하기(5점)
- 32*32 행렬을 Strassen의 알고리즘으로 계산할 때 덧셈의 총 횟수 구하기(5점)



10번 Print Optimal Order에 대한 코드가 주어짐 -> 3단원 p33 ~ 34
- 이 코드의 점화식, 복잡도함수, 차수를 보이고 이를 수학적 귀납법으로 증명하기(10점)